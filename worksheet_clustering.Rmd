---
title: "Hierarchial Cluster"
author: "Ahmet Faruk Uluta≈ü"
date: "2022-10-11"
output:
  html_document:
    toc: yes
    theme: united
---
```{r}

```

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

```


```{r}
#### Worksheet Clustering
##Select statements from the following code and the clusteringR ppt to get protein datamatrix
##generate a distance matrix, dendogram 13x13 of proteins and plot it
##by using eucledian and average linkage and then create also a heamap in an .rmd file 
##then add to your rmd file the answers/plots/code for the following questions.
##your code should plot within the .html when you knit and not send the plot to a pdf

#reading the protein.csv file
prot=read.csv("protein.csv")

#scaling
scaledprot=scale(prot, center=TRUE)

#euclidean distance method
d1=dist(t(scaledprot), method="euclidean")

#average linkage method
hclust(d1,method="average")

#dendrogram plotting
plot(hclust(d1, method="average"))

#heatmap
heatmap(as.matrix(scaledprot))

##QUESTIONS TO ANSWER IN YOUR Rmarkdown (if you do not have enough time complete it at home).
##NOTE: use par() to partition your plots to compare

#QUESTION1: Pick another method to generate your cluster and compare a) topology and b) branchlengths.
#you should generate dendograms and/or heatmaps and comment on differences and similarities
#e.g."euclidean", "maximum", "manhattan", "canberra", "binary" or "minkowski" these are available.

#distance method
d2=dist(t(scaledprot), method="manhattan")

#average linkage method
hclust(d2,method="average")

#dendrogram plotting
par( mfrow= c(1,2) )
plot(hclust(d1,method="average"))
plot(hclust(d2, method="average"))

#heatmap
heatmap(as.matrix(d1))
heatmap(as.matrix(d2))

#a) The topology is the same for both the Manhattan and Euclidian distance measures.
#b) As height increases in the dendrogram created using the Manhattan approach, branchlengths also increase.

#QUESTION2: Compare single linkage with average linkage and comment on topology and branchlengths?
#Use the same distance method to see the effect of linkage.

#distance method
d3=dist(t(scaledprot), method="manhattan")

#average linkage method
hclust1 = hclust(d3,method="single")

#dendrogram plotting
par( mfrow= c(1,2) )
plot(hclust(d2, method="average"))
plot(hclust(d3, method="single"))

#a) For average and single linkage methods, the topology is the same. 
#b) In the dendrogram generated using the average approach, branchlengths increase as height increases.

#QUESTION3: Discuss when would you use average and when would you use single? Or should you use them both? Why or why not?

# If the data are less noisy, a single linkage should be employed (outliers). Between single and full connection, average linkage strikes a balance. In addition, it performs superior to single linkage on a noisy dataset. Selecting the best method for the given dataset can be aided by combining the two of them.

#QUESTION4: generate a heatmap of fractions in which proteins are expressed (6 x 6) instead of (13 x 13).
#Explain what did you do different to get that heatmap.

d4=dist(scaledprot, method="euclidean")
heatmap(as.matrix(d4))

# Instead of transposing the scaledprot variable inside the dist function, I used it directly to obtain the heatmap of fractions.

#QUESTION5: change the color palette of one of the heatmaps you generated to one of your choice. How did you find which pallette you can use? Explain.

library(RColorBrewer)
heatmap(as.matrix(scaledprot), col=colorRampPalette(brewer.pal(8, "Blues"))(25))

# I examined the RColorBrewer palettes and the native R palettes. I went with the one that is created from similar color shades.

#PCA
#normalization of data
rangescale <- function(X) {
  Xmax = apply(X, 2, max)
  Xscaled <- scale(X, scale=Xmax, center=FALSE)
  return(Xscaled)
}
scaleddata <- rangescale(prot)

#a)
?prcomp

#b) Principle Component (PC) scores are generated by x, and loadings are generated by rotation.

#c) The R code used in the lecture notes and the video for visualizing the PC scores differs in that the lecture notes use rotation values whereas the movie uses x values. Using x values to depict the PC scores is the appropriate strategy since x includes the major components.

#d)
result = prcomp(scaleddata, center=FALSE)
result2 = prcomp(t(scaleddata), center=FALSE)
par( mfrow= c(1,2) )

#PC1 vs PC2 showing all fractions
scores = result$x
plot(scores[,1], scores[,2], xlab="PC1", ylab="PC2")
text(scores[,1]+0.005, scores[,2]+0.003, labels = rownames(prot), pos=4)

#PC1 vs PC2 showing all proteins
scores2 = result2$x
plot(scores2[,1], scores2[,2], xlab="PC1", ylab="PC2")
text(scores2[,1]+0.005, scores2[,2]+0.003, labels = colnames(prot), pos=4)

#e) Since the first plot provides the relationship between the fractions by creating PCs that are composed of linear combinations of fractions, and the second plot provides the relationship between the proteins by creating PCs that are composed of linear combinations of proteins, the first plot uses normal data while the second plot uses transposed data.

#f) As proteins (samples) are columns and fractions (variables) are rows, we must transpose the data to identify the relationship between the proteins and utilize the normal matrix to find the relationship between the fractions.
```

